@page "/spreadsheet"
@rendermode InteractiveAuto
@inject IJSRuntime JS  // <remarks> Allows the "communication"/use of javascript </remarks>
@inject NavigationManager Navigator

@namespace SpreadsheetNS  

@using System.Diagnostics

<NavigationLock ConfirmExternalNavigation="true"
                OnBeforeInternalNavigation="OnBeforeLeavePage" />

<PageTitle>Starter Code</PageTitle>

<h1>Simple SpreadSheet GUI @(false ? "*" : "")</h1>

@* <remarks> Example of how to have two pages or an "alert" GUI. </remarks> *@
@if (SaveGUIView)
{
    <label for="SavefileName">Name:</label>
    <input id="SaveFileName" @bind="SaveFileName" type="text">

    <br/>

    <button class="btn btn-primary" @onclick="HandleSaveFile">Save</button>
    <button class="btn btn-primary" @onclick="() => ShowHideSaveGUI(false)">Cancel</button>
}
else
{
    <div id="toolbar">
        <div>
            <label for="SpreadsheetCell">Cell:</label>
            <label for="SelectedCell"> @selectedNameOfCell</label>
            <label for="FormulaValue">Value:</label>
            <input name="FormulaValue" id="FormulaValue" value="@ValueWidgetBackingStore" @onchange="ChangeSpreadsheetCellValue" readonly />
            <label for="FormulaContent">Content:</label>
            <input name="FormulaContent" id="FormulaContent" @ref="FormulaContentEditableInput" value="@InputWidgetBackingStore" @onchange="ChangeSpreadsheetCellValue" />
        </div>
    </div>

    <div class="container" style="cursor: pointer;">
        <div class="table-container">
            <div class="scrollable">
                <table class="table table-bordered">
                    <thead>
                        <tr class="fixed-header">
                            <th scope="col">&nbsp;</th>
                           @*add variable for column length and row lenght and getters and setters.*@
                            @for ( int col = 0; col < 10; col++ )
                            {
                                <th scope="col">@Alphabet[col]</th>
                            }
                        </tr>
                    </thead>

                    <tbody>
                        @for ( int row = 0; row < 10; row++ )
                        {
                            <tr style="padding:0px !important;">
                                <th style="padding:0px !important;" scope="row" class="fixed-column">@(row + 1)</th>
                                @for ( int col = 0; col < 10; col++ )
                                {
                                    int r = row;
                                    int c = col;
                                    <td class="@CellsClassBackingStore[r,c]"  @onclick="() => FocusMainInput(r,c)">
                                        <span title="@CellsBackingStore[r,c] "class="SpreadsheetCell">@CellsBackingStore[r, c]</span>
                                    </td>
                                }
                            </tr>
                        }
                    </tbody>
                </table>
            </div>
        </div>
    </div>

    <div id="FileMenu">
        <h2>File Menu</h2>
        <div id="FileHandlers">
            <button class="btn btn-primary" @onclick="HandleClear">Clear</button>
            <button class="btn btn-primary" @onclick="() => ShowHideSaveGUI(true)">Save</button>
            <div id="hideUglyWidget">
                <InputFile id="inputwidget" name="abc" class="custom-input" type="file" OnChange="HandleLoadFile" />
            </div>
            <label for="inputwidget" class="btn btn-primary">Load</label>
            <br/>

            <label for="RowsInput"> Number of Rows: </label>
            @*Might need to change this to handle bigger values (up to 26 and 100)*@
            <input name="RowsInput" id="RowsInput" min="1" max="10"/>
            <label for="ColsInput"> Number of Cols: </label>
            <input name="ColsInput" id="ColsInput" min="1" max="10"/>
        </div>
    </div>
}

@code
{
    // <remark> 
    //   The code in this section should be 100% GUI related.  Otherwise
    //   place the code in the .cs file.
    // </remark>

    /// <summary>
    ///   Direct reference to the html element (so we can focus it).
    /// </summary>
    private ElementReference FormulaContentEditableInput;

    /// <summary>
    ///   The value of the main input widget where users type
    ///   their formulas and numbers and strings.
    /// </summary>
    private string InputWidgetBackingStore = "";

    private string ValueWidgetBackingStore = "";

    /// <summary>
    ///   The name of the file that we want to download to.
    /// </summary>
    private string SaveFileName = "Spreadsheet.sprd";

    private int selectedRow = 0;
    private int selectedCol = 0;

    private int prevSelectedRow = 0;
    private int prevSelectedCol = 0; 

    private string selectedNameOfCell = "A1";

    /// <summary>
    ///   When a cell is clicked on, put the focus on the main
    ///   widget and update the toolbar.
    /// </summary>
    /// <param name="row"></param>
    /// <param name="col"></param>
    private void FocusMainInput( int row, int col )
    {
        // FIXME: show the user which cell was clicked on
        // Add a new display for Cell name (calling update toolbar)
        prevSelectedCol = selectedCol;
        prevSelectedRow = selectedRow;

        selectedRow = row;
        selectedCol = col;

        selectedNameOfCell = CellNameFromRowCol(row, col);

        UpdateToolbar();
        HighlightCell(row, col);

        FormulaContentEditableInput.FocusAsync(); // <remarks> move focus back to input widget. </remarks>
    }

    /// <summary>
    ///   Make the value and content display/input of the tool bar match the
    ///   spreadsheet.
    /// </summary>
    private void UpdateToolbar()
    {
        InputWidgetBackingStore = CellsBackingStore[selectedRow, selectedCol];

        ValueWidgetBackingStore = CellsBackingValue[selectedRow, selectedCol];

        //CellSelectedWidgetBackingStore = whatever cell is selected

        StateHasChanged();
    }

    /// <summary>
    ///   Outline the current cell. erase outlines from everyone else.
    /// </summary>
    /// <param name="theRow">the cell's row.</param>
    /// <param name="theCol">the cell's col.</param>
    private void HighlightCell(int theRow, int theCol)
    {
        // FIXME: shouldn't use magic constants (e.g., 10).
        // So do we add instance variables that keep track of what is currently selected and then set it to empty using instance variables
        // Are these instance variables in this file or the .cs file? Keep in here figured it out
        // probably should just remember the last cell and empty its backing store.
        // for (int row = 0; row < 10; row++)
        // {
        //     for (int col = 0; col < 10; col++)
        //     {
        //         CellsClassBackingStore[row, col] = string.Empty;
        //     }
        // }

        CellsClassBackingStore[prevSelectedRow, prevSelectedCol] = string.Empty;

        CellsClassBackingStore[theRow, theCol] = "selected";
    }

    /// <summary>
    ///   When the header widget for cell contents is changed, update
    ///   the spreadsheet.
    /// </summary>
    /// <param name="eventArgs"></param>
    private void ChangeSpreadsheetCellValue( ChangeEventArgs eventArgs )
    {
        // FIXME: determine the currently select row, col (hint: it should be saved)
        int row = selectedRow;
        int col = selectedCol;

        string newInput = eventArgs.Value?.ToString() ?? "oops"; // So if user somehow inputs null 
        InputWidgetBackingStore = newInput;
        ValueWidgetBackingStore = CellsBackingValue[row, col];

        HandleUpdateCellInSpreadsheet( newInput, row, col );

        UpdateToolbar();
    }

    /// <summary>
    ///   What to do before the browser is allowed to leave the page.
    /// </summary>
    /// <param name="context"></param>
    /// <returns></returns>
    private async Task OnBeforeLeavePage( LocationChangingContext context )
    {
        if (spreadsheet.Changed) // FIXME: don't confirm if the sheet is not changed.  So basically here instead of true do changed find out how to get changed in here.
        {
            var isConfirmed = await JS.InvokeAsync<bool>(
                "confirm",
                "Are you sure you want to navigate away?");

            if (!isConfirmed)
            {
                context.PreventNavigation();
            }
        }
    }

}