@* // <copyright file="SpreadsheetGUI.razor.cs" company="UofU-CS3500">
    // Copyright (c) 2024 UofU-CS3500. All rights reserved.
    //
</copyright>
// Ignore Spelling: Spreadsheeeeeeeeee

// <summary>
    // Author:    Joel Rodriguez,  Nandhini Ramanathan, and Professor Jim.
    // Partner:   None
    // Date:      October 29, 2024
    // Course:    CS 3500, University of Utah, School of Computing
    // Copyright: CS 3500 and [Joel Rodriguez and Nandhini Ramanathan] - This work may not
    //            be copied for use in Academic Coursework.
    //
    // I, Joel Rodriguez and Nandhini Ramanathan, certify that I wrote this code from scratch and
    // did not copy it in part or whole from another source.  All
    // references used in the completion of the assignments are cited
    // in my README file.
    //
    // File Contents
    //
    //    This file contains the basic structure and idea of a spreadsheet it contains the idea of cells and ways to fill those cells in an
    //    actual spreadsheet. This file is the Model in MVC for our spreadsheet project. We also have ways of handling circular dependencies
    //    and invalid names.
// </summary> *@

@page "/spreadsheet"
@rendermode InteractiveAuto
@inject IJSRuntime JS  // <remarks> Allows the "communication"/use of javascript </remarks>
@inject NavigationManager Navigator

@namespace SpreadsheetNS

@using System.Diagnostics

<NavigationLock ConfirmExternalNavigation="true"
				OnBeforeInternalNavigation="OnBeforeLeavePage" />

<PageTitle>Starter Code</PageTitle>
@* // <remarks> Displays the header with an * if the spreadsheet has unsaved changes. </remarks> *@
<h1>Simple SpreadSheet GUI @(spreadsheet.Changed ? "*" : "")</h1>
@* <remarks> Example of how to have two pages or an "alert" GUI. </remarks> *@
@if (CellsClassBackingStore[0, 0] == null)
{
	CellsClassBackingStore[0, 0] = "selected";
	HighlightCell(0, 0);
}

@*  <remarks> Displays the save dialog, button, and hides the dialogue depending on the state of `SaveGUIView`. </remarks> *@
@if (SaveGUIView)
{
	<label for="SavefileName">Name:</label>
	<input id="SaveFileName" @bind="SaveFileName" type="text">

	<br />

	<button class="btn btn-primary" @onclick="HandleSaveFile">Save</button>
	<button class="btn btn-primary" @onclick="() => ShowHideSaveGUI(false)">Cancel</button>
}
else
{
	<label for="SpreadsheetName">Name: </label>
	<input name="SpreadsheetName" id="NameOfSpreadsheet" value="@NameWidgetBackingStore" @onchange="ChangeSpreadsheetName" />
	@* <remarks> Displays the currently selected cell, its computed value, and an editable input for its contents for the user. </remarks> *@
	<div id="toolbar">
		<div>
			<label for="SpreadsheetCell">Cell:</label>
			<input name="SelectedCell" id="CellToolBar" value="@selectedNameOfCell" readonly />
			<label for="FormulaValue">Value:</label>
			<input name="FormulaValue" id="FormulaValue" value="@ValueWidgetBackingStore" readonly />
			<label for="FormulaContent">Content:</label>
			<input name="FormulaContent" id="FormulaContent" @ref="FormulaContentEditableInput" @bind="@InputWidgetBackingStore" />
		</div>
	</div>


	<div class="table-container colored-spreadsheet">
		<div class="container" style="cursor: pointer;">
			<div class="table-container">
				<div class="scrollable">
					<table class="table table-bordered">
						<thead>
							<tr class="fixed-header">
								<th scope="col">&nbsp;</th>
								@for (int col = 0; col < NumberOfCols; col++)
								{
									<th scope="col">@Alphabet[col]</th>
								}
							</tr>
						</thead>

						<tbody>
							@*<remarks> Loops through each row and column to show cells based on the number inputted by user. </remarks> *@
							@for (int row = 0; row < NumberOfRows; row++)
							{
								<tr style="padding:0px !important;">
									<th style="padding:0px !important;" scope="row" class="fixed-column">@(row + 1)</th>
									@for (int col = 0; col < NumberOfCols; col++)
									{
										int r = row;
										int c = col;
										<td class="@CellsClassBackingStore[r,c]" @onclick="() => FocusMainInput(r,c)">
											@* <remarks> Displays an editable input if the cell is selected or the cell's value if it's not selected. </remarks> *@
											@if (CellsClassBackingStore[r, c] != null && CellsClassBackingStore[r, c].Equals("selected"))
											{
												<input name="FormulaCellContent" id="FormulaCellContents" @ref="FormulaContentEditableInput" @bind="InputWidgetBackingStore" />
											}
											else
											{
												<span title="@CellsBackingStore[r,c] " class="SpreadsheetCell">@CellsBackingValue[r, c] </span>
											}
										</td>
									}
								</tr>
							}
						</tbody>
					</table>
				</div>
			</div>
		</div>
	</div>

	<div id="FileMenu">
		<h2>File Menu</h2>
		<div id="FileHandlers">
			<button class="btn btn-primary" @onclick="HandleClear">Clear</button>
			<button class="btn btn-primary" @onclick="() => ShowHideSaveGUI(true)">Save</button>
			<div id="hideUglyWidget">
				<InputFile id="inputwidget" name="abc" class="custom-input" type="file" OnChange="HandleLoadFile" />
			</div>
			<label for="inputwidget" class="btn btn-primary">Load</label>
			<br />

			@* <remarks> Allows the user to specify the number of rows and columns and stores these in appropriate variables used to render the cells. </remarks> *@
			<label for="RowsInput"> Number of Rows: </label>
			<input type="number" name="RowsInput" id="RowsInput" min="1" max="100" @bind="@NumberOfRows" />
			<label for="ColsInput"> Number of Cols: </label>
			<input type="number" name="ColsInput" id="ColsInput" min="1" max="100" @bind="@NumberOfCols" />
		</div>
	</div>
}

@code
{
	/// <summary>
	///   Direct reference to the html element (so we can focus it).
	/// </summary>
	private ElementReference FormulaContentEditableInput;

	/// <summary>
	///   The value of the main input widget where users type
	///   their formulas and numbers and strings.
	/// </summary>
	private string inputWidgetBackingStore = "";

	/// <summary>
	/// Gets and sets the InputWidgetBackingStore and calls methods checking for inaccurate logic.
	/// </summary>
	private string InputWidgetBackingStore
	{
		get { return inputWidgetBackingStore; }
		set
		{
			int row = selectedRow;
			int col = selectedCol;

			inputWidgetBackingStore = value;
			ValueWidgetBackingStore = CellsBackingValue[row, col];

			HandleUpdateCellInSpreadsheet(value, row, col);

			UpdateToolbar();
		}
	}

	/// <summary>
	/// The name of the spreadsheet. This is an input widget.
	/// </summary>
	private string NameWidgetBackingStore = "default";

	/// <summary>
	/// The evaluated displayed value of the currently selected
	/// spreadsheet cell that is non-editable.
	/// </summary>
	private string ValueWidgetBackingStore = "";

	/// <summary>
	///   The name of the file to save the spreadsheet content.
	/// </summary>
	private string SaveFileName = "default" + ".sprd";

	/// <summary>
	/// Stores the currently selected row index in the spreadsheet.
	/// This value changes when a new cell is selected.
	/// </summary>
	private int selectedRow = 0;

	/// <summary>
	/// Stores the currently selected column index in the spreadsheet.
	/// This value changes when a new cell is selected.
	/// </summary>
	private int selectedCol = 0;

	/// <summary>
	/// Keeps track of the previously selected row index.
	/// It's used to manage state when switching between cells.
	/// </summary>
	private int prevSelectedRow = 0;

	/// <summary>
	/// Keeps track of the previously selected column index.
	/// It's used to manage state when switching between cells.
	/// </summary>
	private int prevSelectedCol = 0;

	/// <summary>
	/// The number of rows initially.
	/// </summary>
	private int numberOfRows = 10;

	/// <summary>
	/// Gets or sets the number of rows in the spreadsheet that
	/// is adjusted by user input.
	/// </summary>
	private int NumberOfRows
	{
		get { return numberOfRows; }
		set
		{
			if (value <= 100 && value >= 1)
			{
				numberOfRows = value;
				RevaluateAllCellsInList(spreadsheet.GetNamesOfAllNonemptyCells().ToList());
			}
			else
			{
				ShowInvalidRowMessage();
			}

		}
	}

	/// <summary>
	/// The number of columns initially.
	/// </summary>
	private int numberOfCols = 10;

	/// <summary>
	/// Gets or sets the number of columns in the spreadsheet that
	/// is adjusted by user input.
	/// </summary>
	private int NumberOfCols
	{
		get { return numberOfCols; }
		set
		{
			if (value <= 26 && value >= 1)
			{
				numberOfCols = value;
				RevaluateAllCellsInList(spreadsheet.GetNamesOfAllNonemptyCells().ToList());
			}
			else
			{
				ShowInvalidColMessage();
			}

		}
	}

	/// <summary>
	/// The name of the currently selected cell,
	/// displayed in the toolbar. First cell "A1" is selected by default.
	/// </summary>
	private string selectedNameOfCell = "A1";

	/// <summary>
	///   When a cell is clicked on, put the focus on the main
	///   widget and update the toolbar.
	/// </summary>
	/// <param name="row">The row index of the selected cell.</param>
	/// <param name="col">The column index of the selected cell.</param>
	private void FocusMainInput(int row, int col)
	{
		prevSelectedCol = selectedCol;
		prevSelectedRow = selectedRow;

		selectedRow = row;
		selectedCol = col;

		selectedNameOfCell = CellNameFromRowCol(row, col);
		if (CellsBackingStore[row, col] != null)
		{
			ToolBarCellContents = CellsBackingStore[row, col];
		}
		else
		{
			ToolBarCellContents = string.Empty;
		}
		UpdateToolbar();
		HighlightCell(row, col);

		// moves focus back to input widget.
		FormulaContentEditableInput.FocusAsync();
	}

	/// <summary>
	///   Make the value and content display/input of the tool bar match the
	///   spreadsheet.
	/// </summary>
	private void UpdateToolbar()
	{
		inputWidgetBackingStore = ToolBarCellContents;
		ValueWidgetBackingStore = CellsBackingValue[selectedRow, selectedCol];
		StateHasChanged();
	}

	/// <summary>
	///   Highlights the currently selected cell and removes highlighting from the previously selected cell.
	/// </summary>
	/// <param name="theRow">The row index of the new cell.</param>
	/// <param name="theCol">The column index of the new cell.</param>
	private void HighlightCell(int theRow, int theCol)
	{
		CellsClassBackingStore[prevSelectedRow, prevSelectedCol] = string.Empty;
		CellsClassBackingStore[theRow, theCol] = "selected";
	}

	/// <summary>
	///   Changes the number of rows in the spreadsheet based on user input.
	/// </summary>
	private async void ShowInvalidRowMessage()
	{
		// We need this helper method to be asyc which is why we can't directly have this line of code in the NumberOfRows setter.
		await JS.InvokeVoidAsync("alert", "Attempted to add invalid value of rows. (Max 100, Min 1).");
	}

	/// <summary>
	///  Shows invalid message if number of cols is invalid
	/// </summary>
	private async void ShowInvalidColMessage()
	{
		// We need this helper method to be asyc which is why we can't directly have this line of code in the NumberOfCols setter.
		await JS.InvokeVoidAsync("alert", "Attempted to add invalid value of columns. (Max 26, Min 1 only whole numbers permitted).");
	}

	/// <summary>
	///  Updates the name of the spreadsheet both in the model and the GUI.
	/// </summary>
	/// <param name="eventArgs"> The input event containing the new cell content. </param>
	private async void ChangeSpreadsheetName(ChangeEventArgs eventArgs)
	{
		string newName = eventArgs.Value?.ToString() ?? "oops";
		if (!newName.Contains('/') && !newName.Equals(string.Empty))
		{
			NameWidgetBackingStore = newName;
			this.spreadsheet.Name = newName;
		}
		else
		{
			NameWidgetBackingStore = "Default";
			spreadsheet.Name = "Default";
			await JS.InvokeVoidAsync("alert", "Spreadsheet naming violation. Spreadsheet names CANNOT contain '/' and must contain at least one character. Name changed to 'Default'");
		}

		StateHasChanged();
	}

	/// <summary>
	///   Confirms with the user before navigating away from the spreadsheet page if there are unsaved changes.
	/// </summary>
	/// <param name="context">The context of the location change, providing control over the navigation event.</param>
	/// <returns>A task that shows/indicates whether navigation was prevented.</returns>
	private async Task OnBeforeLeavePage(LocationChangingContext context)
	{
		if (spreadsheet.Changed)
		{
			var isConfirmed = await JS.InvokeAsync<bool>(
				"confirm",
				"Are you sure you want to navigate away?");

			if (!isConfirmed)
			{
				context.PreventNavigation();
			}
		}
	}
}